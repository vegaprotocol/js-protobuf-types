import recast from "recast";
import parser from "recast/parsers/typescript.js";
import fs from "node:fs";

const snakeToCamel = (str) =>
  str
    .toLowerCase()
    .replace(/([-_][a-z])/g, (group) =>
      group.toUpperCase().replace("-", "").replace("_", "")
    );

const replaceDots = (str) => str.replace(/\./g, "");

const enums = {};
const interfaces = {};
const replaceTypes = {
  "google.protobuf.Value": "any",
  bytes: "string",
};

const generateEnums = (fileJson, b) => {
  return fileJson.enums
    .map(({ longName, values, description }) => {
      const wordsEnum = b.exportNamedDeclaration(
        b.tsEnumDeclaration(
          b.identifier(replaceDots(longName)),
          values.map(({ name, description }) => {
            const v = b.tsEnumMember(b.identifier(name), b.stringLiteral(name));
            v.comments = [b.commentBlock(`* ${description} `)];
            return v;
          })
        )
      );
      const numberEnum = b.exportNamedDeclaration(
        b.tsEnumDeclaration(
          b.identifier(replaceDots(longName) + "Number"),
          values.map(({ name, description, number }) => {
            const v = b.tsEnumMember(
              b.identifier(name),
              b.literal(Number(number))
            );
            v.comments = [b.commentBlock(`* ${description} `)];
            return v;
          })
        )
      );

      wordsEnum.comments = [b.commentBlock(`* ${description}`)];
      numberEnum.comments = [b.commentBlock(`* ${description}`)];
      return [wordsEnum, numberEnum];
    })
    .flat();
};

const getInterfaceFieldType = (field, b) => {
  if (field.longType === "string") return b.tsStringKeyword();
  if (field.longType === "bool") return b.tsBooleanKeyword();
  if (
    ["int64", "uint64", "int32", "uint32", "double", "float"].includes(
      field.longType
    )
  )
    return b.tsUnionType([b.tsStringKeyword(), b.tsNumberKeyword()]);
  return b.tsTypeReference(
    b.identifier(
      enums[field.fullType] ||
        interfaces[field.fullType] ||
        replaceTypes[field.fullType] ||
        field.fullType
    ),
    null
  );
};

const generateInterfaceField = (field, b) => {
  const name = snakeToCamel(field.name);
  const fieldType = getInterfaceFieldType(field, b);
  if (field.label === "repeated") {
    return b.tsPropertySignature(
      b.identifier(name),
      b.tsTypeAnnotation(b.tsArrayType(fieldType)),
      true
    );
  }
  return b.tsPropertySignature(
    b.identifier(name),
    b.tsTypeAnnotation(fieldType),
    true
  );
};

const generateInterface = (message, b) => {
  if (!message.fields) return [];

  return b.exportNamedDeclaration(
    b.tsInterfaceDeclaration(
      b.identifier(replaceDots(message.longName)),
      b.tsInterfaceBody(
        message.fields.map((field) => {
          return generateInterfaceField(field, b);
        })
      )
    )
  );
};

const generateInterfaces = (fileJson, b) => {
  return fileJson.messages
    .map((message) => {
      return generateInterface(message, b);
    })
    .flat();
};

const generateNamespaceHack = (name, content, b) => {
  return [
    b.expressionStatement(b.identifier(`namespace ${name} {`)),
    ...content,
    b.expressionStatement(b.identifier("}")),
  ];
};

const run = async () => {
  const version = process.argv[2];
  console.log("Regenerating for version:", version);
  if (!version) {
    throw new Error("Please provide a version number, e.g. v0.1.0");
  }
  const res = await fetch(
    `https://raw.githubusercontent.com/vegaprotocol/documentation/main/specs/${version}/proto.json`
  );
  const json = await res.json();
  // Some types have dots in their names which does not play well with typescript
  // build a map of all enums and interfaces to be able to replace them
  // with a dot-less version
  for (const file of json.files) {
    const nameSpace = file.package;
    file.enums.forEach(({ fullName, longName }) => {
      enums[fullName] = `${nameSpace}.${replaceDots(longName)}`;
    });
    file.messages.forEach(({ fullName, longName }) => {
      interfaces[fullName] = `${nameSpace}.${replaceDots(longName)}`;
    });
  }

  const b = recast.types.builders;
  const allStatements = json.files
    .map((file) => {
      const enumStatements = generateEnums(file, b);
      const interfaces = generateInterfaces(file, b);
      return generateNamespaceHack(
        file.package,
        [...enumStatements, ...interfaces],
        b
      );
    })
    .flat();

  const ast = b.program(allStatements);
  ast.comments = [
    b.commentBlock(`* Autogenerated file content`),
    b.commentBlock(`* Do not modify`),
    b.commentBlock(`* Generated from v${version}`),
    b.commentBlock(""),
  ];
  const code = recast.print(ast, {
    tabWidth: 2,
    parser,
  }).code;
  fs.writeFileSync("index.ts", code, "utf-8");
};

run()
  .then(() => {
    process.exit(0);
  })
  .catch((error) => {
    console.log(error);
    process.exit(1);
  });
